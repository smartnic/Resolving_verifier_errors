(3)

https://cilium.slack.com/archives/C4XCTGYEM/p1680633810298669

trying to create a load balancer with
cgroup/connect4 hook (like cilium does).

Load error:

11: (85) call bpf_map_lookup_elem#1
invalid indirect read from stack R2 off
-8+6 size 8

full code:

#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>

char _license[] SEC("license") = "GPL";

static int ctx_dst_port(const struct bpf_sock_addr *ctx)
{
	volatile __u32 dport = ctx->user_port;

	return (__be16)dport;
}

void ctx_set_port(struct bpf_sock_addr *ctx, __be16 dport)
{
	ctx->user_port = (__u32)dport;
}

struct lb4_key {
	__be32 address;
	__be16 dport;
};

struct lb4_service {
	__u32 count;
};


struct {
	__uint(type, BPF_MAP_TYPE_LRU_HASH);
	__type(key, struct lb4_key);
	__type(value, struct lb4_service);
	__uint(max_entries, 32);
	__uint(pinning, LIBBPF_PIN_BY_NAME);
} LB4_SERVICES_MAP_V2 SEC(".maps");

struct lb4_backend {
	__be32 address;		/* Service endpoint IPv4 address */
	__be16 port;		/* L4 port filter */
};

struct {
	__uint(type, BPF_MAP_TYPE_HASH);
	__type(key, __u32);
	__type(value, struct lb4_backend);
	__uint(max_entries, 32);
} LB4_BACKEND_MAP SEC(".maps");

static int fwd(struct bpf_sock_addr *ctx) {
	__be16 dst_port = ctx_dst_port(ctx);
	__be32 dst_ip = ctx->user_ip4;
		

	struct lb4_key svckey = {
		.address	= dst_ip, 
		.dport		= dst_port,
	};	

	struct lb4_service *svc = bpf_map_lookup_elem(&LB4_SERVICES_MAP_V2, &svckey);
	if (svc) {
		__u32 rand = bpf_get_prandom_u32();
		__u32 backend_id = (rand % svc->count) + 1;
		
		struct lb4_backend * backend = bpf_map_lookup_elem(&LB4_BACKEND_MAP,&backend_id);
		if (backend) {
			ctx->user_ip4 = backend->address;
			ctx_set_port(ctx, backend->port);
		}
	}

    return 0;

}

SEC("cgroup/connect4")
int proxy(struct bpf_sock_addr *ctx) {
    fwd(ctx);

    return 1;
}

root@ubuntu-nested-5:~/ebpf/libbpf-bootstrap/examples/c/humanz# clang-15 --version
Ubuntu clang version 15.0.7
Target: x86_64-pc-linux-gnu
Thread model: posix
InstalledDir: /usr/bin
root@ubuntu-nested-5:~/ebpf/libbpf-bootstrap/examples/c/humanz# uname -a
Linux ubuntu-nested-5 6.2.5-060205-generic #202303110831 SMP PREEMPT_DYNAMIC Sat Mar 11 13:57:40 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux


full verifier log:

root@ubuntu-nested-5:~/ebpf/libbpf-bootstrap/examples/c/humanz# bpftool prog load socket_nat_lb.o /sys/fs/bpf/humanz_lb  
libbpf: prog 'proxy': BPF program load failed: Permission denied
libbpf: prog 'proxy': -- BEGIN PROG LOAD LOG --
0: R1=ctx(off=0,imm=0) R10=fp0
; int proxy(struct bpf_sock_addr *ctx) {
0: (bf) r6 = r1                       ; R1=ctx(off=0,imm=0) R6_w=ctx(off=0,imm=0)
; volatile __u32 dport = ctx->user_port;
1: (61) r1 = *(u32 *)(r6 +24)         ; R1_w=scalar(umax=4294967295,var_off=(0x0; 0xffffffff)) R6_w=ctx(off=0,imm=0)
; volatile __u32 dport = ctx->user_port;
2: (63) *(u32 *)(r10 -8) = r1         ; R1_w=scalar(umax=4294967295,var_off=(0x0; 0xffffffff)) R10=fp0 fp-8=
; return (__be16)dport;
3: (61) r1 = *(u32 *)(r10 -8)         ; R1_w=scalar(umax=4294967295,var_off=(0x0; 0xffffffff)) R10=fp0
; __be32 dst_ip = ctx->user_ip4;
4: (61) r2 = *(u32 *)(r6 +4)          ; R2_w=scalar(umax=4294967295,var_off=(0x0; 0xffffffff)) R6_w=ctx(off=0,imm=0)
; struct svc_key svckey = {
5: (6b) *(u16 *)(r10 -4) = r1         ; R1_w=scalar(umax=4294967295,var_off=(0x0; 0xffffffff)) R10=fp0 fp-8=??mmmmmm
6: (63) *(u32 *)(r10 -8) = r2         ; R2_w=scalar(umax=4294967295,var_off=(0x0; 0xffffffff)) R10=fp0 fp-8=
7: (bf) r2 = r10                      ; R2_w=fp0 R10=fp0
; 
8: (07) r2 += -8                      ; R2_w=fp-8
; struct svc_val *svc = bpf_map_lookup_elem(&SERVICELIST, &svckey);
9: (18) r1 = 0xffff93e612194800       ; R1_w=map_ptr(off=0,ks=8,vs=4,imm=0)
11: (85) call bpf_map_lookup_elem#1
invalid indirect read from stack R2 off -8+6 size 8
processed 11 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0
-- END PROG LOAD LOG --
libbpf: prog 'proxy': failed to load: -13
libbpf: failed to load object 'socket_nat_lb.o'
Error: failed to load object file

issue: something caused the struct key
to be initialized to 8 bytes,even though
it is only defined to 6.This is from the
compiler.

pahole allows us to check this:

I think this may be due to the compiler
automatically padding the struct to a
4-byte aligned size (so it rounds it up
from 6 to 8 ). Se point 10 "Remove
struct padding with aligning members by
using #pragma pack" of the Cilium BPF
reference  here for more details:

https://docs.cilium.io/en/latest/bpf/toolchain/#tooling-llvm

You can actually check this with pahole.
pahole -C lb4_key your_compiled_bpf_object.o
struct lb4_key {
	__be32                     address;              /*     0     4 */
	__be16                     dport;                /*     4     2 */

	/* size: 8, cachelines: 1, members: 2 */
	/* padding: 2 */
	/* last cacheline: 8 bytes */
};
As you can see, the size is 8 bytes
	(despite the 2 members only
	adding up to 6 bytes) due to the
	compiler adding 2 bytes of
	padding. And the verifier gets
	angry if these hidden padding
	bytes are not initialized. Once
	you manually pad the struct you
	instead get:

pahole -C lb4_key your_compiled_bpf_object.o
struct lb4_key {
	__be32                     address;              /*     0     4 */
	__be16                     dport;                /*     4     2 */
	__u16                      pad;                  /*     6     2 */

	/* size: 8, cachelines: 1, members: 3 */
	/* last cacheline: 8 bytes */
};

the compiler may not only pad the end of the struct, but it may also add padding (or create holes) in the middle of the struct to align members. If we rearrange the struct like this:
struct lb4_key {
	__be16 dport;
	__be32 address;
	__u16 pad;
};
We get:
pahole -C lb4_key your_compiled_bpf_object.o
struct lb4_key {
	__be16                     dport;                /*     0     2 */

	/* XXX 2 bytes hole, try to pack */

	__be32                     address;              /*     4     4 */
	__u16                      pad;                  /*     8     2 */

	/* size: 12, cachelines: 1, members: 3 */
	/* sum members: 8, holes: 1, sum holes: 2 */
	/* padding: 2 */
	/* last cacheline: 12 bytes */
};

So now the compiler has inserted a
2-byte hole between the port and address
members to 4-byte align the address
member. And due to that our manual
padding at the end actually causes the
struct to grow to 10-bytes, so the
compiler then also adds another 2 bytes
of padding to the end, causing the
entire struct to become 12 bytes,
despite our members only taking up 8 of
these bytes. So you have to be somewhat
careful when creating your structs to
try and avoid these types of holes and
padding.


wow, the compiler has done something
which the user cannot immediatley
understand, and __that__ is causing the
verifier error.

